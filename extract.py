#!/usr/bin/env python3
"""
BPF Verifier Function Extractor

Extracts functions from the Linux kernel BPF verifier for verification.
Produces a standalone C file with separated sections:
  1. Type definitions and macros (runtime)
  2. Runtime stubs for irrelevant functions
  3. Extracted code (unmodified from kernel source)
"""

import argparse
import re
import sys
from pathlib import Path
from typing import Optional, List, Tuple, Dict
from dataclasses import dataclass


@dataclass
class ExtractedFunction:
    name: str
    code: str
    source_file: str
    start_line: int
    end_line: int


def find_function_end(lines: List[str], start: int) -> Optional[int]:
    """Find the closing brace of a function starting at given line."""
    brace_count = 0
    found_opening = False

    for i in range(start, len(lines)):
        line = lines[i]
        # Remove string/char literals and comments for brace counting
        clean = re.sub(r'"(?:[^"\\]|\\.)*"', '""', line)
        clean = re.sub(r"'(?:[^'\\]|\\.)*'", "''", clean)
        clean = re.sub(r'//.*$', '', clean)

        for char in clean:
            if char == '{':
                brace_count += 1
                found_opening = True
            elif char == '}':
                brace_count -= 1

        if found_opening and brace_count == 0:
            return i
    return None


def is_forward_declaration(lines: List[str], start: int) -> bool:
    """Check if a function signature is a forward declaration (ends with semicolon)."""
    # Look at the starting line and potentially the next few lines
    # to see if the signature ends with ; before any {
    for i in range(start, min(start + 5, len(lines))):
        line = lines[i].strip()
        if '{' in line:
            return False
        if line.endswith(';'):
            return True
    return False


def extract_function(filepath: Path, func_name: str) -> Optional[ExtractedFunction]:
    """Extract a single function from a source file."""
    content = filepath.read_text()
    lines = content.split('\n')

    # Patterns to match function definitions
    patterns = [
        rf'^static\s+\S+\s+{func_name}\s*\(',
        rf'^static\s+inline\s+\S+\s+{func_name}\s*\(',
        rf'^static\s+__always_inline\s+\S+\s+{func_name}\s*\(',
        rf'^\S+\s+{func_name}\s*\(',
        rf'^struct\s+\w+\s+{func_name}\s*\(',
    ]

    for i, line in enumerate(lines):
        for pattern in patterns:
            if re.search(pattern, line):
                if is_forward_declaration(lines, i):
                    continue
                end = find_function_end(lines, i)
                if end:
                    return ExtractedFunction(
                        name=func_name,
                        code='\n'.join(lines[i:end+1]),
                        source_file=filepath.name,
                        start_line=i + 1,
                        end_line=end + 1
                    )
    return None


def extract_functions(filepath: Path, func_names: List[str]) -> Dict[str, ExtractedFunction]:
    extracted = {}
    for name in func_names:
        result = extract_function(filepath, name)
        if result:
            extracted[name] = result
            print(f"  [OK] {name} ({result.source_file}:{result.start_line}-{result.end_line})",
                  file=sys.stderr)
        else:
            print(f"  [MISSING] {name}", file=sys.stderr)
    return extracted


HEADER = '''\
/*
 * eBPF Verifier Range Analysis - Extracted for SMT Verification
 *
 * This file is auto-generated by extract.py
 *
 * The file is organized into sections:
 *   SECTION 1: Type definitions and macros
 *   SECTION 2: Runtime stubs (simplified implementations for verification)
 *   SECTION 3: Extracted code (unmodified from kernel source)
 */

'''

SECTION_1_TYPES = '''\
/* **************************************************************************
 * SECTION 1: TYPE DEFINITIONS AND MACROS
 * *************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <stddef.h>

#include <linux/bpf.h>

/* Basic types */
typedef uint64_t u64;
typedef int64_t  s64;
typedef uint32_t u32;
typedef int32_t  s32;
typedef uint16_t u16;
typedef int16_t  s16;
typedef uint8_t  u8;
typedef int8_t   s8;

/* Limits */
#define U64_MAX  ((u64)~0ULL)
#define S64_MAX  ((s64)(U64_MAX >> 1))
#define S64_MIN  ((s64)(-S64_MAX - 1))
#define U32_MAX  ((u32)~0U)
#define S32_MAX  ((s32)(U32_MAX >> 1))
#define S32_MIN  ((s32)(-S32_MAX - 1))

/* Tristate number structure */
struct tnum {
    u64 value;
    u64 mask;
};

#define TNUM(_v, _m)  ((struct tnum){.value = (_v), .mask = (_m)})

static const struct tnum tnum_unknown = { .value = 0, .mask = -1 };

static inline bool tnum_is_const(struct tnum a) { return a.mask == 0; }
static inline struct tnum tnum_subreg(struct tnum a) { return TNUM((u32)a.value, (u32)a.mask); }
static inline bool tnum_subreg_is_const(struct tnum a) { return !(tnum_subreg(a)).mask; }

enum bpf_reg_type {
	NOT_INIT = 0,		 /* nothing was written into register */
	SCALAR_VALUE,		 /* reg doesn't contain a valid pointer */
	PTR_TO_CTX,		 /* reg points to bpf_context */
    /* omitted */
};

/* BPF register state - related to the range analysis */
struct bpf_reg_state {
    enum bpf_reg_type type;
    s32 off;
    struct tnum var_off;
    s64 smin_value;
    s64 smax_value;
    u64 umin_value;
    u64 umax_value;
    s32 s32_min_value;
    s32 s32_max_value;
    u32 u32_min_value;
    u32 u32_max_value;
    u32 id;
    u32 ref_obj_id;
    u32 frameno;
    bool precise;
};

/* Verifier environment (simplified) */
struct bpf_verifier_env {
    struct bpf_reg_state fake_reg[2];
    bool bpf_capable;
};

/* Count leading zeros for 64-bit - returns 0-64 */
static inline int ___builtin_clzll(unsigned long long x)
{
	if (x == 0)
		return 64;
	int n = 0;
	if (x <= 0x00000000FFFFFFFFULL) {
		n += 32;
		x <<= 32;
	}
	if (x <= 0x0000FFFFFFFFFFFFULL) {
		n += 16;
		x <<= 16;
	}
	if (x <= 0x00FFFFFFFFFFFFFFULL) {
		n += 8;
		x <<= 8;
	}
	if (x <= 0x0FFFFFFFFFFFFFFFULL) {
		n += 4;
		x <<= 4;
	}
	if (x <= 0x3FFFFFFFFFFFFFFFULL) {
		n += 2;
		x <<= 2;
	}
	if (x <= 0x7FFFFFFFFFFFFFFFULL) {
		n += 1;
	}
	return n;
}

/*
 * Type-generic overflow-checking arithmetic using statement expressions.
 * These work with any integer type (32-bit or 64-bit, signed or unsigned).
 */

/* Unsigned addition overflow: result < a (wrapping detection) */
#define ___builtin_add_overflow(a, b, res)                                        \\
	({                                                                       \\
		typeof(*(res)) __a = (a);                                        \\
		typeof(*(res)) __b = (b);                                        \\
		typeof(*(res)) __r = __a + __b;                                  \\
		*(res) = __r;                                                    \\
		/* For signed: overflow if signs same and result sign differs */ \\
		/* For unsigned: overflow if result < a (wrap) */                \\
		(sizeof(*(res)) <= 4) ?                                          \\
			((typeof(*(res)))-1 < 0) /* signed? */                   \\
				?                                                \\
			(((~(__a ^ __b)) & (__r ^ __a)) >> 31) & 1 :             \\
			__r < __a :                                              \\
		((typeof(*(res)))-1 < 0) /* signed? */                           \\
			?                                                        \\
			(((~((uint64_t)__a ^ (uint64_t)__b)) &                   \\
			  ((uint64_t)__r ^ (uint64_t)__a)) >>                    \\
			 63) & 1 :                                               \\
			__r < __a;                                               \\
	})

/* Unsigned subtraction overflow: a < b (underflow) */
#define ___builtin_sub_overflow(a, b, res)                                       \\
	({                                                                      \\
		typeof(*(res)) __a = (a);                                       \\
		typeof(*(res)) __b = (b);                                       \\
		typeof(*(res)) __r = __a - __b;                                 \\
		*(res) = __r;                                                   \\
		/* For signed: overflow if signs differ and result sign != a */ \\
		/* For unsigned: overflow if a < b */                           \\
		(sizeof(*(res)) <= 4) ?                                         \\
			((typeof(*(res)))-1 < 0) /* signed? */                  \\
				?                                               \\
			(((__a ^ __b) & (__r ^ __a)) >> 31) & 1 :               \\
			__a < __b :                                             \\
		((typeof(*(res)))-1 < 0) /* signed? */                      \\
			?                                                       \\
			((((uint64_t)__a ^ (uint64_t)__b) &                     \\
			  ((uint64_t)__r ^ (uint64_t)__a)) >>                   \\
			 63) & 1 :                                              \\
			__a < __b;                                              \\
	})

#define check_add_overflow(a, b, res) ___builtin_add_overflow(a, b, res)
#define check_sub_overflow(a, b, res) ___builtin_sub_overflow(a, b, res)
// Semantic mismatch, skipping mul verification
#define check_mul_overflow(a, b, res) __builtin_mul_overflow(a, b, res)
#define fls64(x) ((x) ? (64 - ___builtin_clzll(x)) : 0)
#define min(a, b) ((a) < (b) ? (a) : (b))
#define max(a, b) ((a) > (b) ? (a) : (b))
#define min_t(type, a, b) ((type)(a) < (type)(b) ? (type)(a) : (type)(b))
#define max_t(type, a, b) ((type)(a) > (type)(b) ? (type)(a) : (type)(b))

#define __scalar_type_to_expr_cases(type)				\\
		unsigned type:	(unsigned type)0,			\\
		signed type:	(signed type)0

#define __unqual_scalar_typeof(x) typeof(				\\
		_Generic((x),						\\
			 char:	(char)0,				\\
			 __scalar_type_to_expr_cases(char),		\\
			 __scalar_type_to_expr_cases(short),		\\
			 __scalar_type_to_expr_cases(int),		\\
			 __scalar_type_to_expr_cases(long),		\\
			 __scalar_type_to_expr_cases(long long),	\\
			 default: (x)))

#define __minmax_array(op, array, len) ({				\\
	typeof(&(array)[0]) __array = (array);				\\
	typeof(len) __len = (len);					\\
	__unqual_scalar_typeof(__array[0]) __element = __array[--__len];\\
	while (__len--)							\\
		__element = op(__element, __array[__len]);		\\
	__element; })

#define min_array(array, len) __minmax_array(min, array, len)
#define max_array(array, len) __minmax_array(max, array, len)

#define swap(a, b) do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)
#define is_power_of_2(n) ((n) != 0 && (((n) & ((n) - 1)) == 0))

'''

SECTION_2_STUBS = '''\
/* **************************************************************************
 * SECTION 2: RUNTIME STUBS
 * *************************************************************************/

/* Sanitization is orthogonal to soundness */
static inline bool sanitize_needed(u8 opcode)
{
    (void)opcode;
    return false;
}

static inline int sanitize_val_alu(struct bpf_verifier_env *env,
                                   struct bpf_insn *insn)
{
    (void)env; (void)insn;
    return 0;
}

static inline int sanitize_err(struct bpf_verifier_env *env,
                               struct bpf_insn *insn, int ret,
                               void *a, void *b)
{
    (void)env; (void)insn; (void)a; (void)b;
    return ret;
}

static inline int maybe_fork_scalars(struct bpf_verifier_env *env,
                                     struct bpf_insn *insn,
                                     struct bpf_reg_state *reg)
{
    (void)env; (void)insn; (void)reg;
    return 0;
}

/* This is what we are going to verify :) */
static inline int reg_bounds_sanity_check(struct bpf_verifier_env *env,
                                          struct bpf_reg_state *reg,
                                          const char *ctx)
{
    (void)env; (void)reg; (void)ctx;
    return 0;
}

'''

SECTION_3_HEADER = '''\
/* **************************************************************************
 * SECTION 3: EXTRACTED CODE
 * *************************************************************************/

'''


def generate_output(verifier_funcs: Dict[str, ExtractedFunction],
                    tnum_funcs: Dict[str, ExtractedFunction],
                    output_path: Path):
    """Generate the output C file."""

    lines = [HEADER, SECTION_1_TYPES, SECTION_2_STUBS, SECTION_3_HEADER]

    lines.append("/* --- Tnum Operations (from tnum.c) --- */\n")
    tnum_order = [
        'tnum_const', 'tnum_range', 'tnum_lshift', 'tnum_rshift', 'tnum_arshift',
        'tnum_add', 'tnum_sub', 'tnum_neg', 'tnum_and', 'tnum_or', 'tnum_xor',
        'tnum_intersect', 'tnum_overlap', 'tnum_union', 'tnum_mul', 'tnum_cast',
        'tnum_clear_subreg', 'tnum_with_subreg', 'tnum_const_subreg',
    ]
    for name in tnum_order:
        if name in tnum_funcs:
            f = tnum_funcs[name]
            lines.append(f"/* {f.source_file}:{f.start_line}-{f.end_line} */")
            lines.append(f.code)
            lines.append("")

    lines.append("\n/* --- Verifier Helper Functions (from verifier.c) --- */\n")
    helper_order = [
        '__mark_reg_unbounded', '__mark_reg64_unbounded', '__mark_reg32_unbounded',
        '___mark_reg_known', '__mark_reg_known', '__mark_reg32_known',
        '__mark_reg_unknown_imprecise', '__mark_reg_unknown',
        '__update_reg32_bounds', '__update_reg64_bounds', '__update_reg_bounds',
        '__reg32_deduce_bounds', '__reg64_deduce_bounds', '__reg_deduce_mixed_bounds',
        '__reg_deduce_bounds', '__reg_bound_offset', 'reg_bounds_sync',
        '__reg32_bound_s64', '__reg_assign_32_into_64', 'zext_32_to_64',
        'is_reg_const', 'reg_const_value',
    ]
    for name in helper_order:
        if name in verifier_funcs:
            f = verifier_funcs[name]
            lines.append(f"/* {f.source_file}:{f.start_line}-{f.end_line} */")
            lines.append(f.code)
            lines.append("")

    lines.append("\n/* --- Scalar Min/Max Operations (from verifier.c) --- */\n")
    scalar_order = [
        'scalar32_min_max_add', 'scalar_min_max_add',
        'scalar32_min_max_sub', 'scalar_min_max_sub',
        'scalar32_min_max_mul', 'scalar_min_max_mul',
        'scalar32_min_max_and', 'scalar_min_max_and',
        'scalar32_min_max_or', 'scalar_min_max_or',
        'scalar32_min_max_xor', 'scalar_min_max_xor',
        '__scalar32_min_max_lsh', '__scalar64_min_max_lsh',
        'scalar32_min_max_lsh', 'scalar_min_max_lsh',
        'scalar32_min_max_rsh', 'scalar_min_max_rsh',
        'scalar32_min_max_arsh', 'scalar_min_max_arsh',
        'is_safe_to_compute_dst_reg_range',
    ]
    for name in scalar_order:
        if name in verifier_funcs:
            f = verifier_funcs[name]
            lines.append(f"/* {f.source_file}:{f.start_line}-{f.end_line} */")
            lines.append(f.code)
            lines.append("")

    lines.append("\n/* --- Main Entry Point for ALU (from verifier.c) --- */\n")
    if 'adjust_scalar_min_max_vals' in verifier_funcs:
        f = verifier_funcs['adjust_scalar_min_max_vals']
        lines.append(f"/* {f.source_file}:{f.start_line}-{f.end_line} */")
        lines.append(f.code)
        lines.append("")

    lines.append("\n/* --- Jump/Branch Analysis (from verifier.c) --- */\n")
    jump_order = [
        'flip_opcode', 'rev_opcode',
        'is_scalar_branch_taken',
        'regs_refine_cond_op', 'reg_set_min_max',
    ]
    for name in jump_order:
        if name in verifier_funcs:
            f = verifier_funcs[name]
            lines.append(f"/* {f.source_file}:{f.start_line}-{f.end_line} */")
            lines.append(f.code)
            lines.append("")

    lines.append("\n/* End of extracted code */\n")

    output_path.write_text('\n'.join(lines))


def main():
    parser = argparse.ArgumentParser(
        description='Extract BPF verifier functions for SMT verification',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  %(prog)s --verifier path/to/verifier.c --tnum path/to/tnum.c -o output.c
  %(prog)s --kernel-dir /path/to/linux -o output.c
        ''')

    parser.add_argument('--verifier', type=Path,
                        help='Path to verifier.c')
    parser.add_argument('--tnum', type=Path,
                        help='Path to tnum.c')
    parser.add_argument('--kernel-dir', type=Path,
                        help='Path to kernel source (alternative to --verifier/--tnum)')
    parser.add_argument('-o', '--output', type=Path, required=True,
                        help='Output file path')

    args = parser.parse_args()

    if args.kernel_dir:
        verifier_path = args.kernel_dir / 'kernel' / 'bpf' / 'verifier.c'
        tnum_path = args.kernel_dir / 'kernel' / 'bpf' / 'tnum.c'
    else:
        verifier_path = args.verifier
        tnum_path = args.tnum

    if not verifier_path or not verifier_path.exists():
        print(f"Error: verifier.c not found at {verifier_path}", file=sys.stderr)
        sys.exit(1)
    if not tnum_path or not tnum_path.exists():
        print(f"Error: tnum.c not found at {tnum_path}", file=sys.stderr)
        sys.exit(1)

    print(f"Extracting from:", file=sys.stderr)
    print(f"  verifier.c: {verifier_path}", file=sys.stderr)
    print(f"  tnum.c: {tnum_path}", file=sys.stderr)
    print(file=sys.stderr)

    # Functions to extract from verifier.c
    verifier_functions = [
        # ALU range analysis
        'adjust_scalar_min_max_vals',
        'scalar32_min_max_add', 'scalar_min_max_add',
        'scalar32_min_max_sub', 'scalar_min_max_sub',
        'scalar32_min_max_and', 'scalar_min_max_and',
        'scalar32_min_max_mul', 'scalar_min_max_mul',
        'scalar32_min_max_or', 'scalar_min_max_or',
        'scalar32_min_max_xor', 'scalar_min_max_xor',
        '__scalar32_min_max_lsh', '__scalar64_min_max_lsh',
        'scalar32_min_max_lsh', 'scalar_min_max_lsh',
        'scalar32_min_max_rsh', 'scalar_min_max_rsh',
        'scalar32_min_max_arsh', 'scalar_min_max_arsh',
        'is_safe_to_compute_dst_reg_range',
        # Bounds sync helpers
        'reg_bounds_sync',
        '__update_reg_bounds', '__update_reg32_bounds', '__update_reg64_bounds',
        '__reg32_deduce_bounds', '__reg64_deduce_bounds', '__reg_deduce_mixed_bounds',
        '__reg_deduce_bounds', '__reg_bound_offset',
        '__reg32_bound_s64', '__reg_assign_32_into_64', 'zext_32_to_64',
        # reg helpers
        '___mark_reg_known', '__mark_reg_known', '__mark_reg32_known',
        '__mark_reg_known_zero', '__mark_reg_unknown', '__mark_reg_unknown_imprecise',
        '__mark_reg_unbounded', '__mark_reg64_unbounded', '__mark_reg32_unbounded',
        # Jump/branch analysis (focused on scalar branches)
        'reg_set_min_max', 'regs_refine_cond_op',
        'is_scalar_branch_taken',
        'flip_opcode', 'rev_opcode',
        'is_reg_const', 'reg_const_value',
    ]

    tnum_functions = [
        'tnum_const', 'tnum_range', 'tnum_lshift', 'tnum_rshift', 'tnum_arshift',
        'tnum_add', 'tnum_sub', 'tnum_neg', 'tnum_and', 'tnum_or', 'tnum_xor',
        'tnum_intersect', 'tnum_overlap', 'tnum_union', 'tnum_mul', 'tnum_cast',
        'tnum_clear_subreg', 'tnum_with_subreg', 'tnum_const_subreg',
    ]

    print("Extracting from verifier.c:", file=sys.stderr)
    verifier_extracted = extract_functions(verifier_path, verifier_functions)

    print("\nExtracting from tnum.c:", file=sys.stderr)
    tnum_extracted = extract_functions(tnum_path, tnum_functions)

    print(file=sys.stderr)
    generate_output(verifier_extracted, tnum_extracted, args.output)

    total = len(verifier_extracted) + len(tnum_extracted)
    print(f"Extracted {total} functions to {args.output}", file=sys.stderr)


if __name__ == '__main__':
    main()
